# JS: Продвинутое тестирование

## Введение

Основные темы:

- Тестирование ошибок. Снепшот-тесты.
- Фикстуры. Организация тестовых данных.
- Изоляция побочных эффектов. Стабы. Инверсия зависимости.
- Моки. Тестирование методом черного ящика.
- Таймеры. Управление временем.
- Тестирование асинхронного кода.

[книга по тестам](https://github.com/goldbergyoni/javascript-testing-best-practices)

---

## Тестирование ошибок

Основные тесты, которые нужно писать, это тесты на успешные сценарии работы. Но в некоторых ситуациях код должен возвращать ошибки и их тоже бывает нужно проверять. Под ошибками понимаются ситуации, в которых код выбрасывает исключение. В чем их особенность? Посмотрите на тест:

```JS
test('boom!', () => {
  try {
    functionWithException(0)
  }
  catch (e) {
    expect(e).not.toBeNull()
  }
})
```

Этот код пытается протестировать ситуацию, при которой функция `functionWithException()` выбрасывает исключение, если ей передать 0. Как вы думаете, этот тест проверит, что функция действительно порождает исключение?

Правильный ответ — нет. Если функция `functionWithException()` не выбросит исключение, то тест пройдет, так как код не попадет в блок `catch`.

Документация Jest предлагает свой способ тестирования таких ситуаций. Jest позволяет указать количество утверждений, которые должны выполниться в тесте. Если этого не происходит, то Jest сообщает об ошибке:

```js
test('boom!', () => {
  // Количество утверждений, которые должны быть запущены в этом тесте
  expect.assertions(1)

  try {
    functionWithException(0)
  } catch (e) {
    expect(e).not.toBeNull()
  }
})
```

Этот способ крайне опасен. Он порождает хрупкие тесты, которые завязаны на то, как они написаны. Если вы захотите добавить новое утверждение, то тест провалится и придется его править. Вам всегда придется следить за тем, чтобы это число было правильным. Не используйте этот подход, чем больше контекстной зависимости, тем сложнее разобраться в коде и проще наделать ошибок.

И наконец-то мы подобрались к правильному способу. В Jest есть матчер, который самостоятельно отлавливает исключение и проверяет, что оно вообще было сгенерировано.

```js
test('boom!', () => {
  expect(() => {
    functionWithException(0)
  }).toThrow()
})
```

Главная особенность этого матчера в том, что он принимает на вход функцию, которая вызывается внутри. Благодаря этому, он может самостоятельно отследить появление исключения. Этот код не содержит неявного состояния и лишних проверок, он делает ровно то, что нужно делать и не требует от нас слишком много. Более того, теоретически возможен тест, в котором делается сразу несколько проверок на различные исключения. Это значительно сложнее провернуть с предыдущими способами.

Иногда важно не просто поймать исключение, но и убедиться в том, что это ожидаемое исключение. Сделать это можно, передав в матчер `toThrow()` строку, которая должна присутствовать в сообщении исключения.

```js
test('boom!', () => {
  expect(() => {
    functionWithException(0)
  }).toThrow('divide by zero')
})
```

### Tests

#### My

```js
test('boom!', () => {
  expect(() => {
    read('/undefined')
  }).toThrow('no such file')
})

test('boom1!', () => {
  expect(() => {
    read('./__tests__')
  }).toThrow('directory')
})
```

#### Teacher

```js
test('read', () => {
  expect(() => read('/undefined')).toThrow()
  expect(() => read('/etc')).toThrow()
})
```

---

## Побочные эффекты

Проще всего тестировать код, состоящий из чистых функций. Данные на вход, результат на выходе. Никаких неожиданностей, никакого состояния, никакого взаимодействия с внешним миром.

```js
import _ from 'lodash'

expect(_.last([1, 2, 3])).toBe(3)
```

Далеко не весь код можно назвать чистым. Без побочных эффектов не обходится ни одна реальная программа. Результаты вычислений нужно куда-то записать, отправить, сохранить.

Побочные эффекты резко усложняют тестирование, требуют более глубоких навыков написания тестов и лучшего понимания того, как организовывать такой код.

Вот лишь некоторые примеры использования побочных эффектов:

- Случайные числа
- HTTP-запросы
- Отправка писем
- Взаимодействие с базой данных
- Взаимодействие с глобальными переменными
- Чтение и запись файлов
- Оперирование текущим временем

В чем заключается сложность? Представьте себе функцию, которая выполняет отправку письма пользователю:

```js
if (sendGreetingEmail(user)) {
  // Вывести на сайте сообщение о том, что письмо было отправлено
}
```

Вот ее гипотетический тест:

```js
expect(sendGreetingEmail(user)).toBe(true)
```

С этим тестом определенно не все в порядке. Все, что мы тут проверяем — то, что функция возвращает `true`, но мы ничего не знаем о том, отправляет ли эта функция письмо и если отправляет, то какое? Все ли нормально с этим письмом?

Но реальность еще сложнее. Отправлять настоящие письма ни в коем случае нельзя. Во-первых, это не этично по отношению к людям. Во-вторых, даже если отправлять письма на фейковые аккаунты, мы все равно взаимодействуем с внешней системой. Внешние системы — это долго, такие тесты будут выполняться значительно дольше по времени, чем тесты чистых функций. Кроме того, любое взаимодействие с внешней средой не детерминировано. Начиная от того, что сеть не надежна, и эти тесты могут падать с ошибками без видимой на то причины, заканчивая тем, что, за слишком частую отправку писем почтовая служба может заблокировать IP-адрес с которого идет отправка. И, наконец, это может быть небезопасно.

И это только отправка писем. С другими побочными эффектами будут другие сложности. И для их решения потребуются другие подходы к организации кода и тестов. В течение нескольких следующих уроков, мы разберем наиболее распространенные примеры побочных эффектов и того, как правильно с ними работать.

### Tests

#### My

```js
import getFunction from '../functions.js'

const buildUser = getFunction()

// BEGIN (write your solution here)
test('main feature', () => {
  const expectedProperties = ['email', 'firstName', 'lastName']
  const user = buildUser()

  expectedProperties.forEach((key) => expect(user).toHaveProperty(key))

  let user1 = buildUser()
  expect(user1).not.toEqual(user)

  const customUser = buildUser({ firstName: 'Petya' })
  expect(customUser).toHaveProperty('firstName', 'Petya')
})
```

#### Teacher

```js
import getFunction from '../functions.js'

const buildUser = getFunction()

// BEGIN
test('buildUser fields', () => {
  const user1 = buildUser()
  expect(user1).toEqual(
    expect.objectContaining({
      email: expect.any(String),
      firstName: expect.any(String),
      lastName: expect.any(String),
    })
  )
})

test('buildUser random', () => {
  const user1 = buildUser()
  const user2 = buildUser()
  expect(user1).not.toEqual(user2)
})

test('buildUser override', () => {
  const newData1 = {
    email: 'test@email.com',
  }
  const user1 = buildUser(newData1)
  expect(user1).toMatchObject(newData1)
})
```

---

## Тестирование кода, взаимодействующего с файлами

Наиболее типичный побочный эффект — взаимодействие с файлами (файловые операции). В основном это либо чтение файлов, либо запись в них. С чтением разбираться значительно проще, поэтому с него и начнем.

### Чтение файлов

В большинстве случаев чтение файлов не доставляет особых проблем. Оно ничего не изменяет и выполняется локально, в отличие от сетевых запросов. Это значит, что мы вряд ли столкнемся со случайными ошибками, если у нас есть необходимый файл и нужные права.

При тестировании функций, читающих файлы, должно выполняться ровно одно условие. Функция должна позволять менять путь до файла. В таком случае, достаточно создать файл нужной структуры в фикстурах.

```js
// Функция читает файл со списком пользователей системы и возвращает их имена
// В линуксе это файл /etc/passwd
const userNames = readUserNames()
```

В тестах читать **_/etc/passwd_** нельзя, потому что содержимое этого файла зависит от окружения, в котором запущены тесты. Для тестирования нужно создать файл аналогичной структуры в фикстурах и указать его при запуске функции:

```js
import fs from 'fs'
import path from 'path'

const getFixturePath = filename => path.resolve(**dirname, '../__fixtures__/', filename)

test('readUserNames', () => {
// ../__fixtures__/passwd
const passwdPath = getFixturePath('passwd')
const userNames = readUserNames(passwdPath)
expect(userNames).toEqual(/* ожидаемый список */)
})
```

### Запись файлов

С записью файлов уже сложнее. Главная проблема — отсутствие гарантированной идемпотентности. Это значит, что повторный вызов функции, записывающей файлы, может вести себя не как первый вызов, например, завершаться с ошибкой, либо приводить к другим результатам.

Почему? Представьте себе, что мы пишем тесты на функцию `log(message)`, которая дописывает все переданные в нее сообщения в файл:

```js
const log = makeLogger('development.log')
await log('first message')
// cat development.log
// first message
await log('second message')
// cat development.log
// first message
// second message
```

Это значит, что каждый запуск тестов будет немного другим. При первом запуске тестов создается файл для хранения логов. Затем он начнет заполняться. Это приводит к целой пачке проблем:

- Наверняка внутри этой функции процесс создания файла это особый случай, который нужно тестировать отдельно. Повторные запуски тестов перестанут проверять эту ситуацию.
- Сложнее написать предсказуемый тест. Придется дополнительно придумывать хитрые схемы, например проверять только последнюю строку в файле. Такой подход понижает качество теста.
- Не особенно критично, но все же: в процессе запуска тестов появляется файл, который постоянно растет в размерах.

При правильной организации тестов, каждый тест работает в идентичном окружении на каждом запуске. Для этого, например, можно удалять файл после выполнения каждого теста. В Jest есть хук `afterEach` который выполняется после каждого теста. Эту задачу можно попробовать решить с его помощью:

```js
import fs from 'fs'

test('log', async () => {
  const log = makeLogger('development.log')

  await log('first message')
  const data1 = await fs.readFile('development.log', 'utf-8')
  expect(data1).toEqual(/* ... */)

  await log('second message')
  const data2 = await fs.readFile('development.log', 'utf-8')
  expect(data2).toEqual(/* ... */)
})

afterEach(async () => {
  await fs.unlink('development.log')
})
```

В большинстве ситуаций такое решение работает нормально, но все же не во всех. Выполнение кода тестов — это не атомарная операция. Нет никакой гарантии, что хук `afterEach()` выполнится. Есть много причин, по которым это может не произойти, например, из-за самого Jest.

Есть только один надежный способ делать очистку — делать это до теста, а не после, в `beforeEach()`. С таким подходом есть только одна небольшая сложность. При первом запуске тестов файла нет. Это значит, что прямой вызов `unlink()` завершится с ошибкой и тесты не смогут выполниться. Чтобы избежать этого, можно подавить ошибку:

```js
import _ from 'lodash'

beforeEach(async () => {
  await fs.unlink('development.log').catch(_.noop)
})
```

Другой вопрос при записи файлов — куда их сохранять? Однозначно избегайте записи файлов прямо внутри проекта. Если тестируемый код позволяет сконфигурировать место записи, то используйте системную временную директорию. Ее можно получить через модуль **_os_**:

```js
import os from 'os'

console.log(os.tmpdir())
```

### Виртуальная файловая система (ФС)

Это еще один способ тестировать код, работающий с ФС. С помощью [специальной библиотеки](https://github.com/tschaub/mock-fs) во время тестов создается виртуальная файловая система. Она автоматически подменяет реальную файловую систему для модуля _fs_. Это значит, что функцию, которая тестируется, трогать не надо. Эта функция продолжает думать, что она работает с реальным диском. Вся конфигурация при этом задается снаружи:

```js
import mock from 'mock-fs'

// Конфигурация fs
// Любые операции с этими файлами будут происходить в памяти
// без взаимодействия с реальной файловой системой
mock({
  'path/to/fake/dir': {
    'some-file.txt': 'file content here',
    'empty-dir': {
      /** empty directory */
    },
  },
  'path/to/some.png': Buffer.from([8, 6, 7, 5, 3, 0, 9]),
  'some/other/path': {
    /** another empty directory */
  },
})

await fs.unlink('path/to/fake/dir/some-file.txt')
```

Этот способ дает идемпотентность из коробки. Вызов функции `mock` формирует окружение на каждый запуск с нуля. То есть достаточно добавить ее в `beforeEach` и можно приступать к тестированию.

### Tests

#### My

```js
import { fileURLToPath } from 'url'
import os from 'os'
import path from 'path'
import fs from 'fs/promises'
import getFunction from '../functions.js'

const __filename = fileURLToPath(import.meta.url)
const __dirname = path.dirname(__filename)
const prettifyHTMLFile = getFunction()

// BEGIN (write your solution here)
const tmpdir = os.tmpdir()

const getFixturesPath = (filename) =>
  path.resolve(__dirname, '../__fixtures__', filename)
const getTempPath = (filename) => path.resolve(tmpdir, filename)

const afterFile = getFixturesPath('after.html')
const beforeFile = getFixturesPath('before.html')
const tempFilePath = getTempPath('temp.html')

test('prettify main feature', async () => {
  const data1 = await fs.readFile(beforeFile, 'utf-8')
  const data2 = await fs.readFile(afterFile, 'utf-8')

  await fs.writeFile(tempFilePath, data1)
  await prettifyHTMLFile(tempFilePath)

  const result = await fs.readFile(tempFilePath, 'utf-8')

  expect(result).toEqual(data2)
})

afterEach(async () => {
  await fs.unlink(tempFilePath)
})
```

#### Teacher

```js
import { fileURLToPath } from 'url'
import os from 'os'
import path from 'path'
import fs from 'fs/promises'
import getFunction from '../functions.js'

const __filename = fileURLToPath(import.meta.url)
const __dirname = path.dirname(__filename)
const prettifyHTMLFile = getFunction()

// BEGIN
const getFixturePath = (name) =>
  path.join(__dirname, '..', '__fixtures__', name)

const filename = 'before.html'
const dest = path.join(os.tmpdir(), filename)
const src = getFixturePath(filename)

let expected

beforeAll(async () => {
  expected = await fs.readFile(getFixturePath('after.html'), 'utf-8')
})

beforeEach(async () => {
  await fs.copyFile(src, dest)
})

test('prettifyHTMLFile', async () => {
  await prettifyHTMLFile(dest)
  const actual = await fs.readFile(dest, 'utf-8')
  expect(actual).toBe(expected)
})
```

## Инверсия зависимостей

Далеко не всегда результат работы функции связан с побочным эффектом, как это было в предыдущем уроке. Иногда побочный эффект это просто дополнительное действие, которое скорее мешает протестировать основную логику.

Представьте себе функцию, которая регистрирует пользователя. Она создает запись в базе данных и отправляет приветственное письмо:

```js
const params = {
  email: 'lala@example.com',
  password: 'qwerty',
}
registerUser(params)
```

Эта функция делает много всего, но главное, что нас волнует — правильная регистрация пользователя. Типичная регистрация сводится к добавлению в базу данных записи о новом пользователе. Именно это и нужно проверять — наличие новой записи в базе данных с правильно заполненными данными. А вот возврат функции нам никак не поможет.

Как правило, базу данных в тестах не прячут. В веб-фреймворках она доступна в тестовой среде и работает как обычно. Идемпотентность в ней достигается за счет транзакций. Перед тестом транзакция начинается и после теста откатывается. Благодаря этому каждый тест запускается в идентичном окружении и не важно как он его меняет:

```js
// Гипотетический пример
const ctx = /* connect to db */;
beforeEach(() => ctx.beginTransaction());

test('registerUser', () => {
  // Внутри идет добавление данных в базу
  const id = registerUser({ name: 'Mike' });
  const user = User.find(id);
  expect(user).toHaveProperty('name', 'Mike');
})

// За счет отката база возвращается в исходное состояние
afterEach(() => ctx.rollbackTransaction());
```

А вот с отправкой писем все сложнее. Ее точно делать нельзя, но как добиться такого поведения? Посмотрите на то, как примерно может выглядеть функция регистрации пользователя:

```js
import sendEmail from './emailSender.js'
const registerUser = (params) => {
  const user = new User(params)
  if (user.save()) {
    sendEmail('registration', { user })
    return true
  }
  return false
}
```

Существует несколько подходов, позволяющих отключить отправку в тестах. Самый простой — переменная окружения, которая показывает среду выполнения:

```js
// Выполняем этот код только если мы не в тестовой среде
if (process.env.NODE_ENV !== 'test') {
  sendEmail('registration', { user })
}
```

Несмотря на простоту использования, такой подход считается плохой практикой. Формально, из-за него происходит нарушение абстракции, код начинает знать о том, где он выполняется. Со временем таких проверок становится все больше и код становится грязнее. Более того, если нам все же надо убедиться, что письмо отправляется (с правильными данными!), то мы не сможем этого сделать.

Следующий способ — поддержка режима тестирования внутри самой библиотеки. Например, где-нибудь на этапе инициализации тестов можно сделать так:

```js
// setup.js в jest
import sendEmail from './emailSender.js'

// У этого подхода много разновидностей, начиная от установки флага,
// заканчивая заменой функций в прототипе.
sendEmail.test = true
```

Теперь в любом другом месте, где импортируется и используется функция sendEmail(), реальная отправка происходить не будет:

```js
// Ничего не происходит
sendEmail('registration', { user })
// В отличие от первого варианта, прикладной код ни о чем не догадывается
```

Это довольно популярное решение. Обычно информация о том, как правильно включить режим тестирования, находится в официальной документации конкретной библиотеки.

Что делать, если используемая библиотека не поддерживает режим тестирования? Существует еще один, наиболее универсальный способ. Он основан на применении инверсии зависимостей. Программу можно изменить так, чтобы она вызывала функцию `sendEmail()` не напрямую, а принимала ее как параметр:

```js
import sendEmail from './emailSender.js'

// Ставим значение по умолчанию, чтобы не пришлось постоянно указывать функцию
const registerUser = (params, send = sendEmail) => {
  const user = new User(params)
  if (user.save()) {
    send('registration', { user })
    return true
  }
  return false
}
```

Сначала создадим функцию-замену, которая будет имитировать работу реальной функции отправки писем, но без фактической отправки. Внутри этой функции мы можем выполнять какие-то действия, в зависимости от того, что хотим получить. Например, текст письма можно вывести в терминал для удобства отладки. А можем вообще ничего не делать, оставить тело пустым

```js
const fakeSendEmail = (...args) => {
  // Тут выполняем какие-то действия
  // Или вообще ничего не делаем
}
```

Теперь сам тест. Передаем нашу фейковую функцию отправки письма в качестве параметра при регистрации пользователя

```js
test('registerUser', () => {
  const id = registerUser({ name: 'Mike' }, fakeSendEmail)
  const user = User.find(id)
  expect(user).toHaveProperty('name', 'Mike')
})
```

Ее вызов внутри функции `registerUser()` отработает, но письмо отправляться не будет

Такой способ сложнее в реализации, особенно если функция находится глубоко в стеке вызовов. Это значит, что придется прокидывать нужные зависимости через всю цепочку функций сверху вниз. Самих зависимостей может быть много, и чем больше используется инверсия, тем сложнее код. За гибкость приходится платить.

Теперь плюсы. Ни библиотека, ни код ничего не знают про тесты. Этот способ наиболее гибкий, он позволяет задавать конкретное поведение для конкретной ситуации. В некоторых экосистемах инверсия зависимостей определяет процесс сборки приложения. Особенно в мире PHP, Java и C#.
