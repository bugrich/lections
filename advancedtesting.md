# JS: Продвинутое тестирование

## Введение

Основные темы:

- Тестирование ошибок. Снепшот-тесты.
- Фикстуры. Организация тестовых данных.
- Изоляция побочных эффектов. Стабы. Инверсия зависимости.
- Моки. Тестирование методом черного ящика.
- Таймеры. Управление временем.
- Тестирование асинхронного кода.

[книга по тестам](https://github.com/goldbergyoni/javascript-testing-best-practices)

---

## Тестирование ошибок

Основные тесты, которые нужно писать, это тесты на успешные сценарии работы. Но в некоторых ситуациях код должен возвращать ошибки и их тоже бывает нужно проверять. Под ошибками понимаются ситуации, в которых код выбрасывает исключение. В чем их особенность? Посмотрите на тест:

```JS
test('boom!', () => {
  try {
    functionWithException(0)
  }
  catch (e) {
    expect(e).not.toBeNull()
  }
})
```

Этот код пытается протестировать ситуацию, при которой функция `functionWithException()` выбрасывает исключение, если ей передать 0. Как вы думаете, этот тест проверит, что функция действительно порождает исключение?

Правильный ответ — нет. Если функция `functionWithException()` не выбросит исключение, то тест пройдет, так как код не попадет в блок `catch`.

Документация Jest предлагает свой способ тестирования таких ситуаций. Jest позволяет указать количество утверждений, которые должны выполниться в тесте. Если этого не происходит, то Jest сообщает об ошибке:

```js
test('boom!', () => {
  // Количество утверждений, которые должны быть запущены в этом тесте
  expect.assertions(1)

  try {
    functionWithException(0)
  } catch (e) {
    expect(e).not.toBeNull()
  }
})
```

Этот способ крайне опасен. Он порождает хрупкие тесты, которые завязаны на то, как они написаны. Если вы захотите добавить новое утверждение, то тест провалится и придется его править. Вам всегда придется следить за тем, чтобы это число было правильным. Не используйте этот подход, чем больше контекстной зависимости, тем сложнее разобраться в коде и проще наделать ошибок.

И наконец-то мы подобрались к правильному способу. В Jest есть матчер, который самостоятельно отлавливает исключение и проверяет, что оно вообще было сгенерировано.

```js
test('boom!', () => {
  expect(() => {
    functionWithException(0)
  }).toThrow()
})
```

Главная особенность этого матчера в том, что он принимает на вход функцию, которая вызывается внутри. Благодаря этому, он может самостоятельно отследить появление исключения. Этот код не содержит неявного состояния и лишних проверок, он делает ровно то, что нужно делать и не требует от нас слишком много. Более того, теоретически возможен тест, в котором делается сразу несколько проверок на различные исключения. Это значительно сложнее провернуть с предыдущими способами.

Иногда важно не просто поймать исключение, но и убедиться в том, что это ожидаемое исключение. Сделать это можно, передав в матчер `toThrow()` строку, которая должна присутствовать в сообщении исключения.

```js
test('boom!', () => {
  expect(() => {
    functionWithException(0)
  }).toThrow('divide by zero')
})
```

### Tests

#### My

```js
test('boom!', () => {
  expect(() => {
    read('/undefined')
  }).toThrow('no such file')
})

test('boom1!', () => {
  expect(() => {
    read('./__tests__')
  }).toThrow('directory')
})
```

#### Teacher

```js
test('read', () => {
  expect(() => read('/undefined')).toThrow()
  expect(() => read('/etc')).toThrow()
})
```

---

## Побочные эффекты

Проще всего тестировать код, состоящий из чистых функций. Данные на вход, результат на выходе. Никаких неожиданностей, никакого состояния, никакого взаимодействия с внешним миром.

```js
import _ from 'lodash'

expect(_.last([1, 2, 3])).toBe(3)
```

Далеко не весь код можно назвать чистым. Без побочных эффектов не обходится ни одна реальная программа. Результаты вычислений нужно куда-то записать, отправить, сохранить.

Побочные эффекты резко усложняют тестирование, требуют более глубоких навыков написания тестов и лучшего понимания того, как организовывать такой код.

Вот лишь некоторые примеры использования побочных эффектов:

- Случайные числа
- HTTP-запросы
- Отправка писем
- Взаимодействие с базой данных
- Взаимодействие с глобальными переменными
- Чтение и запись файлов
- Оперирование текущим временем

В чем заключается сложность? Представьте себе функцию, которая выполняет отправку письма пользователю:

```js
if (sendGreetingEmail(user)) {
  // Вывести на сайте сообщение о том, что письмо было отправлено
}
```

Вот ее гипотетический тест:

```js
expect(sendGreetingEmail(user)).toBe(true)
```

С этим тестом определенно не все в порядке. Все, что мы тут проверяем — то, что функция возвращает `true`, но мы ничего не знаем о том, отправляет ли эта функция письмо и если отправляет, то какое? Все ли нормально с этим письмом?

Но реальность еще сложнее. Отправлять настоящие письма ни в коем случае нельзя. Во-первых, это не этично по отношению к людям. Во-вторых, даже если отправлять письма на фейковые аккаунты, мы все равно взаимодействуем с внешней системой. Внешние системы — это долго, такие тесты будут выполняться значительно дольше по времени, чем тесты чистых функций. Кроме того, любое взаимодействие с внешней средой не детерминировано. Начиная от того, что сеть не надежна, и эти тесты могут падать с ошибками без видимой на то причины, заканчивая тем, что, за слишком частую отправку писем почтовая служба может заблокировать IP-адрес с которого идет отправка. И, наконец, это может быть небезопасно.

И это только отправка писем. С другими побочными эффектами будут другие сложности. И для их решения потребуются другие подходы к организации кода и тестов. В течение нескольких следующих уроков, мы разберем наиболее распространенные примеры побочных эффектов и того, как правильно с ними работать.

### Tests

#### My

```js
import getFunction from '../functions.js'

const buildUser = getFunction()

// BEGIN (write your solution here)
test('main feature', () => {
  const expectedProperties = ['email', 'firstName', 'lastName']
  const user = buildUser()

  expectedProperties.forEach((key) => expect(user).toHaveProperty(key))

  let user1 = buildUser()
  expect(user1).not.toEqual(user)

  const customUser = buildUser({ firstName: 'Petya' })
  expect(customUser).toHaveProperty('firstName', 'Petya')
})
```

#### Teacher

```js
import getFunction from '../functions.js'

const buildUser = getFunction()

// BEGIN
test('buildUser fields', () => {
  const user1 = buildUser()
  expect(user1).toEqual(
    expect.objectContaining({
      email: expect.any(String),
      firstName: expect.any(String),
      lastName: expect.any(String),
    })
  )
})

test('buildUser random', () => {
  const user1 = buildUser()
  const user2 = buildUser()
  expect(user1).not.toEqual(user2)
})

test('buildUser override', () => {
  const newData1 = {
    email: 'test@email.com',
  }
  const user1 = buildUser(newData1)
  expect(user1).toMatchObject(newData1)
})
```
